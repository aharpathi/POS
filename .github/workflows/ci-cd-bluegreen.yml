name: CI/CD Pipeline (Blue-Green)

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main

env:
  IMAGE_NAME: myapp
  REGISTRY: docker.io
  DOCKER_USER: ${{ secrets.DOCKER_USER }}
  DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
  K8S_NAMESPACE_STAGING: staging
  K8S_NAMESPACE_PROD: production
  SERVICE_NAME: myapp-service
  APP_LABEL: myapp
  SERVICE_PORT: 80
  CONTAINER_PORT: 8080   # container port the app listens on

jobs:
  build-test:
    name: Build & Test
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.tag.outputs.IMAGE_TAG }}
    steps:
      - name: Checkout Source
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Install Dependencies
        run: npm ci

      - name: Run Unit Tests
        run: npm test

      - name: Code Quality Check (SonarCloud)
        uses: SonarSource/sonarcloud-github-action@master
        with:
          args: >
            -Dsonar.projectKey=myapp
            -Dsonar.organization=myorg
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

      - name: Security Scan (Trivy) - repo scanning
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: fs
          scan-ref: .

      - name: Set image tag
        id: tag
        run: |
          echo "IMAGE_TAG=${GITHUB_SHA::8}" >> $GITHUB_OUTPUT

      - name: Build Docker Image
        run: docker build -t $REGISTRY/$DOCKER_USER/$IMAGE_NAME:${{ steps.tag.outputs.IMAGE_TAG }} .

      - name: Login to Docker Registry
        env:
          DOCKER_USER: ${{ secrets.DOCKER_USER }}
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
        run: echo $DOCKER_PASSWORD | docker login -u $DOCKER_USER --password-stdin $REGISTRY

      - name: Push Docker Image
        run: docker push $REGISTRY/$DOCKER_USER/$IMAGE_NAME:${{ steps.tag.outputs.IMAGE_TAG }}

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-test
    steps:
      - name: Checkout (for k8s manifests)
        uses: actions/checkout@v4

      - name: Decode kubeconfig and configure kubectl (staging)
        env:
          KUBE_CONFIG_STAGING: ${{ secrets.KUBE_CONFIG_STAGING }}
        run: |
          echo "$KUBE_CONFIG_STAGING" | base64 --decode > /tmp/kubeconfig_staging
          mkdir -p $HOME/.kube
          KUBECONFIG=/tmp/kubeconfig_staging kubectl get nodes --kubeconfig=/tmp/kubeconfig_staging

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Deploy to staging (kubectl apply)
        env:
          IMAGE: ${{ env.REGISTRY }}/${{ secrets.DOCKER_USER }}/${{ env.IMAGE_NAME }}:${{ needs.build-test.outputs.image-tag }}
          KUBECONFIG: /tmp/kubeconfig_staging
        run: |
          # substitute image into staging patch (or alter your k8s manifests accordingly)
          kubectl -n ${{ env.K8S_NAMESPACE_STAGING }} apply -f k8s/staging/ --kubeconfig=$KUBECONFIG
          kubectl -n ${{ env.K8S_NAMESPACE_STAGING }} set image deployment/${{ env.APP_LABEL }} ${{
            env.APP_LABEL
          }}=$IMAGE --kubeconfig=$KUBECONFIG
          kubectl -n ${{ env.K8S_NAMESPACE_STAGING }} rollout status deployment/${{ env.APP_LABEL }} --kubeconfig=$KUBECONFIG

  deploy-production-bluegreen:
    name: Blue-Green Deploy to Production
    runs-on: ubuntu-latest
    needs: build-test
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout (for k8s manifests & templates)
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Decode kubeconfig (production)
        env:
          KUBE_CONFIG_PROD: ${{ secrets.KUBE_CONFIG_PROD }}
        run: |
          echo "$KUBE_CONFIG_PROD" | base64 --decode > /tmp/kubeconfig_prod
          export KUBECONFIG=/tmp/kubeconfig_prod
          kubectl --kubeconfig=/tmp/kubeconfig_prod get ns || true

      - name: Determine current color and choose new color
        id: color
        env:
          KUBECONFIG: /tmp/kubeconfig_prod
          SERVICE_NAME: ${{ env.SERVICE_NAME }}
          NAMESPACE: ${{ env.K8S_NAMESPACE_PROD }}
        run: |
          set -e
          # Try to read the version selector from service
          CURRENT=$(kubectl -n $NAMESPACE get svc $SERVICE_NAME -o jsonpath='{.spec.selector.version}' --kubeconfig=$KUBECONFIG 2>/dev/null || true)
          if [ -z "$CURRENT" ]; then
            # fallback: check deployments labeled app=<APP_LABEL>
            CURRENT=$(kubectl -n $NAMESPACE get deployments -l app=${{ env.APP_LABEL }} -o=jsonpath='{range .items[*]}{.metadata.labels.version}{"\n"}{end}' --kubeconfig=$KUBECONFIG | grep -v '^$' | head -n1 || true)
          fi
          if [ -z "$CURRENT" ]; then
            echo "No current color found, defaulting to blue"
            CURRENT=green
          fi
          if [ "$CURRENT" = "blue" ]; then
            NEW=green
          else
            NEW=blue
          fi
          echo "current=$CURRENT" >> $GITHUB_OUTPUT
          echo "new=$NEW" >> $GITHUB_OUTPUT
          echo "Selected new color: $NEW (current was $CURRENT)"

      - name: Render deployment template for new color
        env:
          IMAGE_TAG: ${{ steps.tag.outputs.IMAGE_TAG || needs.build-test.outputs.image-tag }}
          IMAGE: ${{ env.REGISTRY }}/${{ secrets.DOCKER_USER }}/${{ env.IMAGE_NAME }}:${{ needs.build-test.outputs.image-tag }}
          COLOR: ${{ steps.color.outputs.new }}
          NAMESPACE: ${{ env.K8S_NAMESPACE_PROD }}
          KUBECONFIG: /tmp/kubeconfig_prod
        run: |
          # Use envsubst to substitute COLOR and IMAGE into a deployment template file
          env | sort
          mkdir -p /tmp/k8s-out
          envsubst < k8s/deployment-bluegreen-template.yaml > /tmp/k8s-out/deployment-${COLOR}.yaml
          # apply the new deployment
          kubectl -n $NAMESPACE apply -f /tmp/k8s-out/deployment-${COLOR}.yaml --kubeconfig=$KUBECONFIG
          # wait for rollout
          kubectl -n $NAMESPACE rollout status deployment/${{ env.APP_LABEL }}-${COLOR} --kubeconfig=$KUBECONFIG --timeout=120s

      - name: Run smoke test against new color (port-forward then curl)
        env:
          KUBECONFIG: /tmp/kubeconfig_prod
          NAMESPACE: ${{ env.K8S_NAMESPACE_PROD }}
          SERVICE_NAME: ${{ env.SERVICE_NAME }}
          COLOR: ${{ steps.color.outputs.new }}
          PORT: ${{ env.SERVICE_PORT }}
        run: |
          set -e
          # Port-forward service to localhost
          kubectl -n $NAMESPACE port-forward svc/$SERVICE_NAME 9999:$PORT --kubeconfig=$KUBECONFIG >/tmp/portforward.log 2>&1 &
          PF_PID=$!
          echo "Port-forward started (pid $PF_PID), waiting 2s..."
          sleep 2
          echo "Curling health endpoint..."
          if curl -sS --max-time 10 http://localhost:9999/healthz ; then
            echo "Smoke test passed"
            kill $PF_PID || true
          else
            echo "Smoke test FAILED"
            kill $PF_PID || true
            # Abort so workflow can rollback
            exit 1
          fi

      - name: Switch service selector to new color
        env:
          KUBECONFIG: /tmp/kubeconfig_prod
          NAMESPACE: ${{ env.K8S_NAMESPACE_PROD }}
          SERVICE_NAME: ${{ env.SERVICE_NAME }}
          COLOR: ${{ steps.color.outputs.new }}
        run: |
          # patch the service selector to point to new color
          kubectl -n $NAMESPACE patch svc $SERVICE_NAME --type='json' -p="[{\"op\":\"replace\",\"path\":\"/spec/selector/version\",\"value\":\"${COLOR}\"}]" --kubeconfig=$KUBECONFIG || \
          kubectl -n $NAMESPACE patch svc $SERVICE_NAME --type='json' -p="[{\"op\":\"add\",\"path\":\"/spec/selector/version\",\"value\":\"${COLOR}\"}]" --kubeconfig=$KUBECONFIG
          echo "Service $SERVICE_NAME now points to color ${COLOR}"

      - name: Cleanup old color deployment (optional)
        env:
          KUBECONFIG: /tmp/kubeconfig_prod
          NAMESPACE: ${{ env.K8S_NAMESPACE_PROD }}
          OLD_COLOR: ${{ steps.color.outputs.current }}
        run: |
          if [ -n "${OLD_COLOR}" ]; then
            echo "Scaling down & deleting deployment ${OLD_COLOR}"
            kubectl -n $NAMESPACE scale deployment/${{ env.APP_LABEL }}-${OLD_COLOR} --replicas=0 --kubeconfig=$KUBECONFIG || true
            kubectl -n $NAMESPACE delete deployment/${{ env.APP_LABEL }}-${OLD_COLOR} --ignore-not-found --kubeconfig=$KUBECONFIG || true
          else
            echo "No old color recorded; skipping cleanup"
          fi

